# 1 为什么我们需要并发？

首先，并发(`cocurrency`)和并行 (`parallism`)是两个不同的概念

- 并发是逻辑上同时多个任务执行；
- 并行是物理上同时多个任务执行；

对于单核CPU处理器，无论如何设计，都是并行执行的代码，而并发可以通过CPU分配时间片来完成。在计算机早期的时候，所有机器在同一个时刻只运行一个程序，也叫单任务处理器。在后来随着个人电脑（PC）的兴起，我们对计算机有了更高的要求，比如在浏览网页的时候，也可以通过音乐播放器播放音乐，而后台的电子邮件程序不停的接受邮件。这样我们设计出多任务处理器，将CPU运行划分为一个个时间片，不同运行程序拥有不同的时间片，由于时间片划分非常短，以致我们觉察不出来程序运行有任何中断，这种设计是并发。通过设计出虚拟内存的机制，使每个进程仿佛独立拥有自己的内存，但是这样的导致不同进程之间进行无法共享变量。比如在使用文档编辑器的时候，你希望程序（比如 `MS Word`)既可以接受你的键盘的输入，也可以对你的输入进行单词检查，这样就设计出更线程(`thread`)，每个进程包含了大量的线程，每个线程拥有自己的线程栈，但是可以共享进程的堆栈( `heap` )，达到不同线程之间通信的功能，而CPU时间片调度也转换为线程为单位。
通过并发，我们实现了计算机多任务处理的能力，而且对于计算密集的任务，多线程设计可以争取更多的CPU计算时间片，加快任务运行速度。对于 `Web` 服务器，每一个请求都需要创建新的线程来响应请求。

# 3 什么是竞争条件？举一个例子来描述？

竞争条件发生在多个线程访问同一个共享数据的时候，它们都尝试去修改这个数据。由于线程调度算法可以在任何时候修改它们的执行的顺序，所以你不会知道哪一个线程有优先执行，这就会导致最终的结果由线程调度算法决定。
问题往往发生在对共享数据执行`Read-Modify-Write`的操作，由于`CPU`执行的粒度比代码执行的程序更小，如果在执行`Write`之前，线程被调度算法切换出去了，那么就会导致最终的结果和预期不一致。

```go
if x == 0 {
    x = x + 1
}
```

执行的过程如何首先读取 `x` 的值是否为`0`，如果满足条件，则修改它加1，然后在写回到内存那种。中间的过程通常借助寄存器完成计算，如果在执行中间过程中，线程被切换出去，那么导致另外的线程取得的`x`值任然为内存，导致最终的结果不一致。